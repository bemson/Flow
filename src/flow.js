/*!
 * Flow (NextGen) v0.X
 * http://github.com/bemson/Flow/tree/nextGen
 *
 * Dependencies:
 * genData v1.2 / Bemi Faison (c) 2011 / MIT (http://github.com/bemson/genData)
 *
 * Copyright 2011, Bemi Faison
 * Released under the MIT License
 */
!function (inCommonJsEnv, Array, Object, window, undefined) {
  // if in a web environment and Flow already exists...
  if (!inCommonJsEnv && window.Flow) {
    // don't re-initialize Flow
    return;
  }
  var
    // set the environent to expose Flow to
    environment = (inCommonJsEnv) ? exports : window,
    // load or alias genData, based on the execution environment
    genData = (inCommonJsEnv ? require('genData') : window).genData,
    // the number of Flow instances created
    flowCnt = 0,
    // private signature object for priviledged access
    secretObject = {},
    // collection of package-definitions
    pkgDefs = [],
    // name index of package-definitions
    pkgsIdx = {},
    // tests the name and/or value of a state, against each package definition's targeted handler
    testStateKey = function (testAction, name, value) {
      // return false if the name is empty, or true when the handler of any package-definition returns true
      return name.length && pkgDefs.some(function (pkgDef) {
        var
          // alias the targeted action in this package
          hdlr = pkgDef.pkg[testAction];
        // based on the type of action...
        switch (typeof hdlr) {
          case 'function' :
            // return result of the package-defintion's function; pass the name and value to be tested
            return hdlr(name, value);
          case 'object' :
            // if the handler is a regular expression...
            if (hdlr instanceof RegExp) {
              // return result of testing the given name with this package-definition's regexp
              return hdlr.test(name);
            }
        }
        // return false by default, to skip to the next package-definition (needed?)
        // return false;
      });
    },
    // spawn generator to extract states from the program parameter
    genStates = new genData(
      function (name, value, parent, dataset, flags) {
        var
          // alias state
          state = this,
          // flag whether this item is a invalid key
          isInvalidKey = testStateKey('invalidKey', name, value),
          // flag whether this item is an attribute key
          isAttributeKey = testStateKey('attributeKey', name, value);
        // if this state's key is invalid or flagged as an attribute (by one any of the packages)...
        if (isInvalidKey || isAttributeKey) {
          // exclude from dataset
          flags.omit = 1;
          // don't scan this value
          flags.scan = 0;
          // if this item is an attribute...
          if (isAttributeKey && !isInvalidKey) {
            // add to the parent attribute's state
            parent.attributes[name] = value;
          }
        } else { // otherwise, when this key is not invalid or an attribute...
          // set default property values to undefined (presence reduces prototype property lookups)
          state.inContext = state.parentIndex = state.previousIndex = state.nextIndex = state.firstChildIndex = undefined;
          // capture index of this item once added
          state.index = dataset.length + 1;
          // capture depth
          state.depth = parent ? parent.depth + 1 : 1; // start depth at 1, since _flow state will be prepended later
          // set name
          state.name = parent ? name : '_root';
          // init attributes property - holds all attributes of this state
          state.attributes = {};
          // start or extend parent path
          state.path = parent ? parent.path + name + '/' : '//';
          // init child collection
          state.children = [];
          // if there is a parent state...
          if (parent) {
            // set parent index
            state.parentIndex = parent.index;
            // if there are no children, set first child index
            if (!parent.children.length) parent.firstChildIndex = state.index;
            // capture the index of this state in the parent's child collection
            state.childIndex = parent.children.push(state.index) - 1;
            // set this state as the last child of the parent
            parent.lastChildIndex = state.index;
            // if not the first child...
            if (state.childIndex) {
              // reference index of previous state
              state.previousIndex = parent.children[state.childIndex - 1];
              // reference index of this state in the previous state
              dataset[state.previousIndex - 1].nextIndex = state.index;
            }
          }
        }
      }
    ),
    // spawn generator to clone the states generated by the genStates generator
    genCloneStates = new genData(
      function (name, value, parent, dataset, flags) {
        // if this is the array container...
        if (!parent) {
          // exclude from the dataset
          flags.omit = 1;
        } else { // otherwise, when a state object...
          // don't scan further
          flags.scan = 0;
          // with each state property available...
          for (var mbr in value) {
            // if this member is not inherited...
            if (value.hasOwnProperty(mbr)) {
              // copy key and value to new data object
              this[mbr] = value[mbr];
            }
          }
        }
      }
    ),
    arrayPrototype = Array.prototype; // alias for minification purposes
  /**
    Shims for missing native object methods (on crap browsers).
    WARNING: These methods are not robust and do no validation! They merely support the needs of this library.
    Shim these methods yourself before loading this script, if you want something equivalent to https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/
    Ofcourse, we're targeting IE here. I didn't want to include this, but - then again - no one wants to work with IE... We just have to.
  */
  if (!arrayPrototype.some) {
    arrayPrototype.some = function(fnc, scope) {
      for (var i = 0, j = this.length; i < j; i++) {
        if (fnc.call(scope, this[i], i, this)) {
          return true;
        }
      }
      return false;
    };
  }
  if (!arrayPrototype.filter) {
    arrayPrototype.filter = function(fnc, scope) {
      var
        results = [],
        i = 0,
        j = this.length,
        value;
      for (; i < j; i++) {
        value = this[i];
        if (fnc.call(scope, value, i, this)) {
          results.push(value);
        }
      }
      return results;
    };
  }
  if (!arrayPrototype.forEach) {
    arrayPrototype.forEach = function(fnc, scope) {
      for (var i = 0, j = this.length; i < j; i++) {
        fnc.call(scope, this[i], i, this);
      }
    };
  }
  if (!arrayPrototype.map) {
    arrayPrototype.map = function(fnc, scope) {
      var
        i = 0,
        j = this.length,
        results = new Array(j);
      for (; i < j; i++) {
        results[i] = fnc.call(scope, this[i], i, this);
      }
      return results;
    };
  }

  // define prototype base for FlowAPI instances
  function ProxyModel() {}

  // make sure it's constructor points to the public Flow(API) function (since instanceof won't help)
  ProxyModel.prototype.constructor = FlowAPI;

  // define prototype base for package-definitions
  function pkgModel() {}

  // create a package
  function definePackage(name) {
    var
      // get what will be the index of this package definition
      pkgIndex = pkgDefs.length;
    // package returns the private instance of it's public proxy
    function pkgDef(pxy) {
      var
        // attempt to retrieve the private flow via the custom toString handshake
        flow = pxy && pxy.toString(secretObject);
      // return the package instance registered at this package definitions index
      return flow instanceof Flow && (flow.pkgs[pkgIndex] || {}).pkg || false;
    }
    // extend the package model chain (for identification purposes)
    pkgDef.prototype = new pkgModel();
    // set default static members
    pkgDef.init = pkgDef.attributeKey = pkgDef.invalidKey = pkgDef.onBegin = pkgDef.onEnd = pkgDef.onTraverse = 0;
    // define new proxy-model for this package
    function pxyModel() {}
    // chain existing ProxyModel to this model
    pxyModel.prototype = new ProxyModel();
    // define new ProxyModel from this extended chain
    ProxyModel = pxyModel;
    // expose the model's prototype in the package-definition
    pkgDef.proxy = pxyModel.prototype;
    // define new state constructor
    function stateModel() {}
    // expose the state's prototype in the package-definition
    pkgDef.state = stateModel.prototype;
    // define and index this package definition
    pkgsIdx[name] = pkgDefs.push({
      name: name,
      pkg: pkgDef,
      model: pxyModel,
      state: stateModel
    }) - 1;
    // return the package definition function
    return pkgDef;
  }

  function createProgramStates(program) {
    var
      // parse initial states
      states = genStates(program);
    // set parent and childIndex of the "_root" state
    states[0].parentIndex = states[0].childIndex = 0;
    // prepend the "_flow" state
    states.unshift(genStates()[0]);
    // with the _flow state...
    with (states[0]) {
      // reference index of root as child of flow
      children.push(1);
      // set name
      name = '_flow';
      // set index
      index = 0;
      // set depth
      depth = 0;
      // set path
      path = '..//';
    }
    // reference the first and last child index
    states[0].firstChildIndex = states[0].lastChildIndex = 1;
    // return states
    return states;
  }

  function Flow(program, proxy, customConfig) {
    var
      // alias self (for closures)
      flow = this;
    // capture original program (for cloning purposes)
    flow.prgm = program;
    // generate states from the program
    flow.states = createProgramStates(program);
    // define tank pkg api - all package instances control the tank via these members
    flow.tank = {
      // increment and capture the number of Flow instantiations
      id: ++flowCnt,
      // index of the current program state
      currentIndex: 0,
      // index of the target program state (-1 indicates idle or at rest)
      targetIndex: -1,
      // define scoped call to stop this flow
      stop: function () {
        // set internal stop flag
        flow.stop = 1;
        // return truthy when this flow is in a loop, otherwise falsy
        return flow.loop;
      },
      // add and remove post-loop functions
      post: function (param) {
        // based on the type
        switch (typeof param) {
          case 'function':
            // return the index of the callback after adding it to this flow's post queue
            return flow.posts.push(param) - 1;
          break;

          case 'number':
            // if the target is a valid...
            if (flow.posts[param]) {
              // clear the callback at this index
              flow.posts[param] = 0;
              // return success
              return true;
            }
        }
        // (otherwise) flag that this call failed
        return false;
      }
    };
    // init collection of post(ed) functions
    flow.posts = [];
    // init current state reference
    flow.current = flow.states[0];
    // init target state and loop flags
    flow.target = flow.loop = 0;
    // create packages registry
    flow.pkgs = pkgDefs.map(function (pkgDef) {
      var
        // init pkg registry
        pkgEntry = {
          // capture package name for lookups
          name: pkgDef.name
        };
      // define base package
      function pkgInst() {}
      // extend the base package prototype
      pkgInst.prototype = new pkgDef.pkg();
      // define the package-instance for this entry as a new pkgBase
      pkgEntry.pkg = new pkgInst();
      // clone states and pass to this package-entry's instance
      pkgEntry.pkg.states = genCloneStates(
        // states to copy
        flow.states,
        // pass no additional parsers
        0,
        // set the prototype of the returned data object, with this package-definition's state constructor
        pkgDef.state
      );
      // expose tank api to this package instance
      pkgEntry.pkg.tank = flow.tank;
      // expose public proxy to this package instance
      pkgEntry.pkg.proxy = proxy;
      // if there is an initialization function in this package-definition...
      if (typeof pkgDef.pkg.init === 'function') {
        // initialize the package instance - pass the customConfig
        pkgDef.pkg.init.call(pkgEntry.pkg, customConfig);
      }
      // return the package entry to the registry
      return pkgEntry;
    });
    // add tank.go() now - after package-instances have initialized - to prevent definitions from directing this flow instance
    flow.tank.go = function (tgtIndex) {
      var
        // alias the target state (if any)
        tgtState = flow.states[tgtIndex];
      // if a valid state was targeted...
      if (tgtState) {
        // capture the targeted state
        flow.target = tgtState;
        // set target index
        flow.tank.targetIndex = tgtState.index;
      }
      // clear internal stop flag
      flow.stop = 0;
      // return number of steps traversed
      return flow.go();
    };
  }

  Flow.prototype = {
    // head towards the current target
    go: function () {
      var
        // alias self
        flow = this,
        // alias states (for minification & performance)
        states = flow.states,
        // alias tank (for minification & performance)
        tank = flow.tank,
        // direction of traversal movement
        dir,
        // the number of traversal events fired
        traversals = 0,
        // alias the current state (for minification & performance)
        curState = flow.current,
        // flag when the nextInt is an event (when 0) or state index (when 1)
        nextIsEvent = 0,
        // integer representing the state index or event type
        nextInt = 0,
        // flag when we've fired the end event
        firedEnd;
      // if already looping...
      if (flow.loop) {
        // flag true if there is a current target
        return !!flow.target;
      }
      // reset the posts array
      flow.posts = [];
      // flag that this flow is looping
      flow.loop = 1;
      // fire begin event
      flow.fire('Begin');
      // while looping...
      while (flow.loop) {
        // if there is a target and we haven't stopped...
        if (flow.target && !flow.stop) {
          // reset firedEnd flag
          firedEnd = 0;
          // get traversal direction
          dir = flow.target.index - curState.index;
          // if going forwards or backwards...
          if (dir) {
            // if going forward on the _flow or _root state, or the target path contains the current path...
            if ((dir > 0 && curState.index < 2) || !flow.target.path.indexOf(curState.path)) {
              // if already in context...
              if (curState.inContext) {
                // flag that we're switching states
                nextIsEvent = 0;
                // target the first child
                nextInt = curState.firstChildIndex;
              } else { // otherwise, if not in context...
                // flag that we're doing an event
                nextIsEvent = 1;
                // set to in event
                nextInt = 1;
                // flag that we're in the current state
                curState.inContext = 1;
              }
            } else { // otherwise, if the target path is not in the current path...
              // if in the context of the current state...
              if (curState.inContext) {
                // flag that we're doing an event
                nextIsEvent = 1;
                // set to out event
                nextInt = 2;
                // flag that we're out of the current state
                curState.inContext = 0;
              } else { // otherwise, when out of this state...
                // if the current state's parent is an ancestor of the target state...
                if (flow.target.path.indexOf(states[curState.parentIndex].path)) {
                  // set direction to backwards
                  dir = -1;
                }
                // predict next event based on the direction
                nextInt = dir < 0 ? 4 : 3;
                // if the last event was out, matches the calculated one, or shows an over occurring after bover (or vice versa)...
                if (curState.lastEvent === 2 || curState.lastEvent === nextInt || curState.lastEvent + nextInt === 7) {
                  // flag that we're changing states
                  nextIsEvent = 0;
                  // go forward, backward, or up based on direction
                  nextInt = dir > 0 ? curState.nextIndex : (curState.previousIndex || curState.parentIndex);
                } else { // otherwise, when the last event was not out and won't be repeated...
                  // flag that we're doing an event (the one previously calculated)
                  nextIsEvent = 1;
                }
              }
            }
          } else { // otherwise, when on the target state...
            // flag that we're doing an event
            nextIsEvent = 1;
            // set event to on or in, based on the current context
            nextInt = curState.inContext ? 0 : 1;
            // if already in context...
            if (curState.inContext) {
              // clear internal target
              flow.target = 0;
              // clear tank target (set to negative one)
              tank.targetIndex = -1;
            }
            // set context to in
            curState.inContext = 1;
          }
          // if doing an event...
          if (nextIsEvent) {
            // capture last event
            curState.lastEvent = nextInt;
            // tick traversal event count
            traversals++;
            // fire traverse event with the resolved next target
            flow.fire('Traverse', [nextInt]);
          } else { // otherwise, when changing the current state...
            // reset lastEvent flag from the current state
            curState.lastEvent = 0;
            // set internal current state
            curState = flow.current = states[nextInt];
            // set tank target
            tank.currentIndex = nextInt;
          }
        } else if (!firedEnd && (flow.stop || !flow.target)) { // or, when stopped and we did not fire the stop event and we've stopped...
          // note that we've fired the end event
          firedEnd = 1;
          // fire end event
          flow.fire('End');
        } else { // (otherwise), when none of these conditions are met...
          // flag that we're done looping
          flow.loop = 0;
        }
      }
      // fire post-loop functions
      flow.posts.forEach(function (fnc) {
        if (typeof fnc === 'function') {
          // execute this post-function
          fnc();
        }
      });
      // return the number of traversal events fired
      return traversals;
    },
    // fire package event
    fire: function (evtName, args) {
      // use args or array - assumes args is an array
      args = args || [];
      // prepend event name
      args.unshift(evtName.toLowerCase());
      // prepend evtName with "on" prefix
      evtName = 'on' + evtName;
      // with each package instance...
      this.pkgs.forEach(function (pkgInst) {
        var
          // get callback from this package instance's definition
          callback = pkgDefs[pkgsIdx[pkgInst.name]].pkg[evtName];
        // if the callback is a function...
        if (typeof callback === 'function') {
          // execute call back in scope of the package instance, with given args
          callback.apply(pkgInst.pkg, args);
        }
      });
    }
  };

  /**
  * program may be an existing flow - this effectively clones the Flow - this is not for performance but convenience
  */
  function FlowAPI(program, customConfig) {
    // if invoked without the "new" operator...
    if (!(this instanceof arguments.callee)) {
      // throw an error
      throw new Error('Missing "new" operator.');
    }
    var
      // define pkgs collection for this Flow
      apiPkgs = {},
      // create public proxy for the private flow instance and for package-instances
      flowProxy = new (getFlowProxy()),
      // init private flow
      flow = new Flow(
        // when "program" is an existing proxy or package, use the original program
        program instanceof ProxyModel ? program.toString(secretObject).prgm :
        (program instanceof pkgModel ? program.proxy.toString(secretObject).prgm : program),
        // pass the public proxy, for referncing by package-instances
        flowProxy,
        // ensure any customConfig is an object, else ignore it
        customConfig instanceof Object ? customConfig : {}
      );
    // faux toString method, for accessing the private flow
    function proxyToString(key) { // faux toString method
      // return corresponding flow or default toString result
      return key === secretObject ? flow : Object.prototype.toString.apply(this, arguments);
    }
    // return an API container for the private flow
    function getFlowProxy() {
      // return anonymous pointer to the private flow
      function api() {
        // reference pkgs for targeted method calls
        this.pkgs = apiPkgs;
        // add custom
        this.toString = proxyToString;
      }
      // use the ProxyModel as the default prototype
      api.prototype = new ProxyModel();
      // return anonymous proxy instance
      return api;
    }
    // with each package-definition...
    pkgDefs.forEach(function (pkgDef) {
      var
        // get unique proxy constructor
        apiProxy = getFlowProxy();
      // prototype this proxy for this package
      apiProxy.prototype = new pkgDef.model();
      // add package methods to this proxy's pkgs object
      apiPkgs[pkgDef.name] = new apiProxy();
    });
    // return the flow proxy
    return flowProxy;
  }

  // define object pointing to flow
  // set prototype to given model
  FlowAPI.pkg = function (name) {
    // if arguments passed...
    if (arguments.length) {
      // if given a valid name to resolve...
      if (typeof name === 'string' && /\w/.test(name)) {
        // if no package has this name...
        if (!pkgsIdx.hasOwnProperty(name)) {
          // create new package definition
          definePackage(name);
        }
        // return the package definition's pkg function
        return pkgDefs[pkgsIdx[name]].pkg;
      }
      // (otherwise) flag that the package name is invalid
      return false;
    }
    // (otherwise) return list of package names
    return pkgDefs.map(function (pkgDef) {
      // extract the package name
      return pkgDef.name;
    });
  }

  // export/expose Flow
  environment.Flow = FlowAPI;
}(typeof require !== 'undefined', Array, Object, this);